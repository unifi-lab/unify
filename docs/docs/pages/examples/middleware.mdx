# Middleware

This guide demonstrates how to use middleware with Unify API for authentication, logging, validation, and other cross-cutting concerns.

## Overview

Middleware in Unify API allows you to:
- Add authentication and authorization
- Log requests and responses
- Validate requests before processing
- Transform data
- Handle CORS
- Rate limiting
- Error handling

## Basic Middleware Structure

```typescript
import { Context, Next } from 'hono';

const myMiddleware = async (c: Context, next: Next) => {
  // Pre-processing logic
  console.log(`Request: ${c.req.method} ${c.req.url}`);
  
  // Call the next middleware or handler
  await next();
  
  // Post-processing logic
  console.log(`Response: ${c.res.status}`);
};
```

## Authentication Middleware

### JWT Authentication

```typescript
import { jwt } from 'hono/jwt';
import { Context, Next } from 'hono';

// JWT middleware for protected routes
const jwtAuth = jwt({
  secret: process.env.JWT_SECRET!,
});

// Custom auth verification
const authMiddleware = async (c: Context, next: Next) => {
  const token = c.req.header('Authorization')?.replace('Bearer ', '');
  
  if (!token) {
    return c.json({ error: 'No token provided' }, 401);
  }
  
  try {
    const decoded = await verifyJWT(token);
    c.set('user', decoded);
    await next();
  } catch (error) {
    return c.json({ error: 'Invalid token' }, 401);
  }
};

// Apply to source
source.register({
  id: "protected-api",
  middleware: [authMiddleware],
  entities: {
    user: {
      findMany: async (args) => {
        // Access user from context
        // const user = c.get('user'); // Available in handler
        return users;
      }
    }
  }
});
```

### API Key Authentication

```typescript
const apiKeyAuth = async (c: Context, next: Next) => {
  const apiKey = c.req.header('X-API-Key');
  
  if (!apiKey) {
    return c.json({ error: 'API key required' }, 401);
  }
  
  const isValid = await validateApiKey(apiKey);
  if (!isValid) {
    return c.json({ error: 'Invalid API key' }, 401);
  }
  
  await next();
};
```

### Role-Based Access Control

```typescript
const requireRole = (requiredRole: string) => {
  return async (c: Context, next: Next) => {
    const user = c.get('user');
    
    if (!user || user.role !== requiredRole) {
      return c.json({ error: 'Insufficient permissions' }, 403);
    }
    
    await next();
  };
};

// Usage
source.register({
  id: "admin-api",
  entities: {
    user: {
      middleware: [authMiddleware, requireRole('admin')],
      delete: async (args) => {
        // Only admins can delete users
        return deleteUser(args.where);
      }
    }
  }
});
```

## Logging Middleware

### Request Logging

```typescript
import { logger } from 'hono/logger';

// Built-in Hono logger
const requestLogger = logger();

// Custom logging middleware
const customLogger = async (c: Context, next: Next) => {
  const start = Date.now();
  const method = c.req.method;
  const url = c.req.url;
  const userAgent = c.req.header('User-Agent');
  
  console.log(`[${new Date().toISOString()}] ${method} ${url}`);
  console.log(`User-Agent: ${userAgent}`);
  
  await next();
  
  const duration = Date.now() - start;
  console.log(`Completed in ${duration}ms - Status: ${c.res.status}`);
};

// Apply globally
const source = createSource();
const app = source.getApp();
app.use('*', customLogger);
```

### Structured Logging

```typescript
import winston from 'winston';

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
});

const structuredLogger = async (c: Context, next: Next) => {
  const requestId = crypto.randomUUID();
  const start = Date.now();
  
  logger.info('Request started', {
    requestId,
    method: c.req.method,
    url: c.req.url,
    userAgent: c.req.header('User-Agent'),
    ip: c.req.header('CF-Connecting-IP') || c.req.header('X-Forwarded-For')
  });
  
  c.set('requestId', requestId);
  
  try {
    await next();
    
    logger.info('Request completed', {
      requestId,
      duration: Date.now() - start,
      status: c.res.status
    });
  } catch (error) {
    logger.error('Request failed', {
      requestId,
      error: error.message,
      stack: error.stack
    });
    throw error;
  }
};
```

## Validation Middleware

### Request Validation

```typescript
import { z } from 'zod';

const validateRequest = (schema: z.ZodSchema) => {
  return async (c: Context, next: Next) => {
    try {
      const body = await c.req.json();
      const validated = schema.parse(body);
      c.set('validatedData', validated);
      await next();
    } catch (error) {
      if (error instanceof z.ZodError) {
        return c.json({
          error: 'Validation failed',
          details: error.errors
        }, 400);
      }
      throw error;
    }
  };
};

// Usage
const UserCreateSchema = z.object({
  name: z.string().min(1),
  email: z.string().email(),
  age: z.number().min(0)
});

source.register({
  id: "validated-api",
  entities: {
    user: {
      create: {
        middleware: [validateRequest(UserCreateSchema)],
        handler: async (args) => {
          const validatedData = c.get('validatedData');
          return createUser(validatedData);
        }
      }
    }
  }
});
```

### Query Parameter Validation

```typescript
const validateQuery = (schema: z.ZodSchema) => {
  return async (c: Context, next: Next) => {
    try {
      const query = c.req.query();
      const validated = schema.parse(query);
      c.set('validatedQuery', validated);
      await next();
    } catch (error) {
      if (error instanceof z.ZodError) {
        return c.json({
          error: 'Invalid query parameters',
          details: error.errors
        }, 400);
      }
      throw error;
    }
  };
};
```

## CORS Middleware

```typescript
import { cors } from 'hono/cors';

// Basic CORS
const corsMiddleware = cors();

// Custom CORS configuration
const customCors = cors({
  origin: ['https://myapp.com', 'https://admin.myapp.com'],
  allowMethods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowHeaders: ['Content-Type', 'Authorization'],
  credentials: true,
});

// Apply to source
const app = source.getApp();
app.use('*', customCors);
```

## Rate Limiting Middleware

```typescript
import { RateLimiter } from 'limiter';

// Simple rate limiter
const rateLimiter = new Map<string, RateLimiter>();

const rateLimit = (requestsPerMinute: number) => {
  return async (c: Context, next: Next) => {
    const clientId = c.req.header('X-Forwarded-For') || 'unknown';
    
    if (!rateLimiter.has(clientId)) {
      rateLimiter.set(clientId, new RateLimiter(requestsPerMinute, 'minute'));
    }
    
    const limiter = rateLimiter.get(clientId)!;
    
    if (limiter.tryRemoveTokens(1)) {
      await next();
    } else {
      return c.json({ error: 'Rate limit exceeded' }, 429);
    }
  };
};

// Usage
source.register({
  id: "rate-limited-api",
  middleware: [rateLimit(100)], // 100 requests per minute
  entities: { /* ... */ }
});
```

## Caching Middleware

```typescript
const cache = new Map<string, { data: any; expires: number }>();

const cacheMiddleware = (ttlMinutes: number = 5) => {
  return async (c: Context, next: Next) => {
    const key = `${c.req.method}:${c.req.url}`;
    const cached = cache.get(key);
    
    if (cached && cached.expires > Date.now()) {
      return c.json(cached.data);
    }
    
    await next();
    
    // Cache GET requests only
    if (c.req.method === 'GET' && c.res.status === 200) {
      const data = await c.res.clone().json();
      cache.set(key, {
        data,
        expires: Date.now() + (ttlMinutes * 60 * 1000)
      });
    }
  };
};
```

## Data Transformation Middleware

```typescript
const transformResponse = async (c: Context, next: Next) => {
  await next();
  
  // Transform response data
  if (c.res.status === 200) {
    const data = await c.res.clone().json();
    
    const transformedData = {
      success: true,
      data: data,
      timestamp: new Date().toISOString(),
      requestId: c.get('requestId')
    };
    
    // Replace response
    c.res = new Response(JSON.stringify(transformedData), {
      status: 200,
      headers: {
        'Content-Type': 'application/json'
      }
    });
  }
};
```

## Middleware Composition

### Combining Multiple Middleware

```typescript
const createSecureEntity = (handlers: any) => ({
  middleware: [
    authMiddleware,
    rateLimit(50),
    customLogger,
  ],
  ...handlers
});

// Usage
source.register({
  id: "secure-api",
  entities: {
    user: createSecureEntity({
      findMany: async (args) => { /* ... */ },
      create: async (args) => { /* ... */ }
    })
  }
});
```

### Conditional Middleware

```typescript
const conditionalAuth = async (c: Context, next: Next) => {
  const isPublicEndpoint = c.req.path.includes('/public');
  
  if (isPublicEndpoint) {
    await next();
  } else {
    await authMiddleware(c, next);
  }
};
```

## Testing Middleware

```typescript
import { testClient } from 'hono/testing';

describe('Auth Middleware', () => {
  it('should reject requests without token', async () => {
    const res = await testClient(app).user.list.$get();
    expect(res.status).toBe(401);
  });
  
  it('should allow requests with valid token', async () => {
    const res = await testClient(app).user.list.$get({
      headers: { Authorization: 'Bearer valid-token' }
    });
    expect(res.status).toBe(200);
  });
});
```

## Best Practices

1. **Keep middleware focused**: Each middleware should have a single responsibility
2. **Order matters**: Apply middleware in the correct order (auth before rate limiting)
3. **Error handling**: Always handle errors appropriately in middleware
4. **Performance**: Be mindful of middleware performance impact
5. **Testing**: Test middleware separately from business logic
6. **Documentation**: Document middleware behavior and dependencies

## Example: Complete Middleware Stack

```typescript
import { createSource } from 'unify-api';
import { logger } from 'hono/logger';
import { cors } from 'hono/cors';

const source = createSource();
const app = source.getApp();

// Global middleware (order matters)
app.use('*', cors());
app.use('*', logger());
app.use('*', structuredLogger);

// Protected routes
app.use('/api/protected/*', authMiddleware);
app.use('/api/admin/*', requireRole('admin'));

// Rate limiting for public API
app.use('/api/public/*', rateLimit(100));

source.register({
  id: "complete-api",
  entities: {
    user: {
      findMany: async (args) => { /* ... */ }
    }
  }
});

export default {
  port: 3000,
  fetch: app.fetch
};
```

This comprehensive middleware setup provides authentication, logging, CORS, rate limiting, and error handling for a production-ready API. 