---
title: Creating Custom Plugins
description: Learn how to create custom plugins for Unify with entities, adapters, and complete implementations.
---

## Overview

Plugins in Unify allow you to extend functionality by defining custom entities and data source adapters. A plugin consists of:

- **Entities**: Data structures that define your domain models
- **Adapters**: Implementations that handle data operations for specific sources
- **Registration**: Plugin configuration that connects entities with adapters

## Plugin Structure

A typical plugin has the following structure:

```
my-plugin/
├── src/
│   ├── entities/
│   │   └── my-entity.ts
│   ├── adapters/
│   │   └── my-adapter.ts
│   ├── plugins/
│   │   └── index.ts
│   └── index.ts
├── package.json
└── tsconfig.json
```

## Step-by-Step Guide

### 1. Define Your Entity

Entities define the structure of your data. Use decorators from `@unilab/core` to specify field types:

```typescript
// src/entities/product.ts
import { Fields } from "@unilab/core";

export class ProductEntity {
  @Fields.string()
  id = "";

  @Fields.string()
  name = "";

  @Fields.string()
  description = "";

  @Fields.number()
  price = 0;

  @Fields.string()
  category = "";

  @Fields.boolean()
  inStock = true;

  @Fields.date()
  createdAt = new Date();
}
```

### 2. Create Data Source Adapter

Adapters implement the `DataSourceAdapter` interface to handle CRUD operations:

```typescript
// src/adapters/product-adapter.ts
import { 
  DataSourceAdapter, 
  FindManyArgs, 
  FindOneArgs, 
  CreationArgs, 
  UpdateArgs, 
  DeletionArgs 
} from "@unilab/core";
import { ProductEntity } from "../entities/product";

// Mock data for demonstration
const productData: ProductEntity[] = [
  {
    id: "1",
    name: "Laptop",
    description: "High-performance laptop",
    price: 999.99,
    category: "Electronics",
    inStock: true,
    createdAt: new Date("2024-01-01")
  },
  {
    id: "2",
    name: "Coffee Mug",
    description: "Ceramic coffee mug",
    price: 12.99,
    category: "Kitchen",
    inStock: true,
    createdAt: new Date("2024-01-02")
  }
];

export class ProductAdapter implements DataSourceAdapter<ProductEntity> {
  async findMany(args?: FindManyArgs<ProductEntity>): Promise<ProductEntity[]> {
    let results = [...productData];
    
    // Apply filtering
    if (args?.where) {
      results = results.filter(product => {
        return Object.entries(args.where!).every(([key, value]) => {
          const productValue = product[key as keyof ProductEntity];
          return productValue === value;
        });
      });
    }
    
    // Apply ordering
    if (args?.order_by) {
      const [field, direction] = Object.entries(args.order_by)[0];
      results.sort((a, b) => {
        const aVal = a[field as keyof ProductEntity];
        const bVal = b[field as keyof ProductEntity];
        const modifier = direction === "desc" ? -1 : 1;
        return aVal > bVal ? modifier : aVal < bVal ? -modifier : 0;
      });
    }
    
    // Apply pagination
    if (args?.offset) {
      results = results.slice(args.offset);
    }
    if (args?.limit) {
      results = results.slice(0, args.limit);
    }
    
    return results;
  }

  async findOne(args: FindOneArgs<ProductEntity>): Promise<ProductEntity | null> {
    const product = productData.find(p => {
      return Object.entries(args.where).every(([key, value]) => {
        return p[key as keyof ProductEntity] === value;
      });
    });
    
    return product || null;
  }

  async create(args: CreationArgs<ProductEntity>): Promise<ProductEntity> {
    const newProduct: ProductEntity = {
      id: (productData.length + 1).toString(),
      name: args.data.name || "",
      description: args.data.description || "",
      price: args.data.price || 0,
      category: args.data.category || "",
      inStock: args.data.inStock ?? true,
      createdAt: new Date()
    };
    
    productData.push(newProduct);
    return newProduct;
  }

  async update(args: UpdateArgs<ProductEntity>): Promise<ProductEntity> {
    const index = productData.findIndex(p => {
      return Object.entries(args.where).every(([key, value]) => {
        return p[key as keyof ProductEntity] === value;
      });
    });
    
    if (index === -1) {
      throw new Error("Product not found");
    }
    
    productData[index] = { ...productData[index], ...args.data };
    return productData[index];
  }

  async delete(args: DeletionArgs<ProductEntity>): Promise<boolean> {
    const index = productData.findIndex(p => {
      return Object.entries(args.where).every(([key, value]) => {
        return p[key as keyof ProductEntity] === value;
      });
    });
    
    if (index === -1) {
      return false;
    }
    
    productData.splice(index, 1);
    return true;
  }
}
```

### 3. Create the Plugin Definition

Define your plugin by combining entities and adapters:

```typescript
// src/plugins/index.ts
import { Plugin } from "@unilab/core";
import { ProductEntity } from "../entities/product";
import { ProductAdapter } from "../adapters/product-adapter";

export const ProductPlugin: Plugin = {
  entities: [ProductEntity],
  adapters: [
    {
      source: "product",
      entityName: "ProductEntity",
      adapter: new ProductAdapter()
    }
  ]
};
```

### 4. Export Plugin Components

Create the main entry point for your plugin:

```typescript
// src/index.ts
export * from "./entities/product";
export * from "./adapters/product-adapter";
export * from "./plugins";
```

## Advanced Features

### Multiple Data Sources

You can create multiple adapters for the same entity to support different data sources:

```typescript
// src/adapters/database-product-adapter.ts
export class DatabaseProductAdapter implements DataSourceAdapter<ProductEntity> {
  // Implementation for database operations
  async findMany(args?: FindManyArgs<ProductEntity>): Promise<ProductEntity[]> {
    // Connect to database and query products
    // ... database implementation
  }
  
  // ... other methods
}

// src/adapters/api-product-adapter.ts
export class APIProductAdapter implements DataSourceAdapter<ProductEntity> {
  // Implementation for API operations
  async findMany(args?: FindManyArgs<ProductEntity>): Promise<ProductEntity[]> {
    // Make HTTP requests to external API
    // ... API implementation
  }
  
  // ... other methods
}

// Updated plugin definition
export const ProductPlugin: Plugin = {
  entities: [ProductEntity],
  adapters: [
    {
      source: "memory",
      entityName: "ProductEntity",
      adapter: new ProductAdapter()
    },
    {
      source: "database",
      entityName: "ProductEntity",
      adapter: new DatabaseProductAdapter()
    },
    {
      source: "api",
      entityName: "ProductEntity",
      adapter: new APIProductAdapter()
    }
  ]
};
```

### Complex Entity Relationships

Define entities with relationships using custom field types:

```typescript
// src/entities/category.ts
export class CategoryEntity {
  @Fields.string()
  id = "";

  @Fields.string()
  name = "";

  @Fields.string()
  description = "";
}

// Updated product entity with relationship
export class ProductEntity {
  @Fields.string()
  id = "";

  @Fields.string()
  name = "";

  @Fields.string()
  description = "";

  @Fields.number()
  price = 0;

  @Fields.string()
  categoryId = "";

  // Relationship field (handled in adapter)
  category?: CategoryEntity;

  @Fields.boolean()
  inStock = true;

  @Fields.date()
  createdAt = new Date();
}
```

## Using Your Plugin

### Server Setup

Register your plugin in a Unify server:

```typescript
// server.ts
import { Unify } from "@unilab/unify-hono";
import { ProductPlugin } from "./my-plugin";

const app = Unify.init({
  plugins: [ProductPlugin]
});

export default {
  port: 3000,
  fetch: app.fetch
};
```

### Client Usage

Use your plugin entities from the client:

```typescript
// client.ts
import { repo, UnifyClient } from "@unilab/unify-client";
import { ProductEntity } from "./my-plugin";

UnifyClient.init({
  baseUrl: "http://localhost:3000",
  timeout: 10000
});

// Create a product
const createProduct = async () => {
  const product = await repo<ProductEntity>("product", "memory").create({
    data: {
      name: "New Product",
      description: "A great product",
      price: 29.99,
      category: "General",
      inStock: true
    }
  });
  console.log("Created product:", product);
};

// Find products
const getProducts = async () => {
  const products = await repo<ProductEntity>("product", "memory").findMany({
    where: { category: "Electronics" },
    limit: 10,
    order_by: { price: "desc" }
  });
  console.log("Products:", products);
};

// Update a product
const updateProduct = async () => {
  const updated = await repo<ProductEntity>("product", "memory").update({
    where: { id: "1" },
    data: { price: 899.99 }
  });
  console.log("Updated product:", updated);
};

createProduct();
getProducts();
updateProduct();
```

## Testing Your Plugin

Create tests for your plugin components:

```typescript
// tests/product-adapter.test.ts
import { ProductAdapter } from "../src/adapters/product-adapter";
import { ProductEntity } from "../src/entities/product";

describe("ProductAdapter", () => {
  let adapter: ProductAdapter;

  beforeEach(() => {
    adapter = new ProductAdapter();
  });

  test("should find all products", async () => {
    const products = await adapter.findMany();
    expect(products).toHaveLength(2);
  });

  test("should find product by id", async () => {
    const product = await adapter.findOne({ where: { id: "1" } });
    expect(product).toBeTruthy();
    expect(product?.name).toBe("Laptop");
  });

  test("should create new product", async () => {
    const newProduct = await adapter.create({
      data: {
        name: "Test Product",
        price: 19.99,
        category: "Test"
      }
    });
    expect(newProduct.id).toBeTruthy();
    expect(newProduct.name).toBe("Test Product");
  });
});
```

## Package Configuration

Create a proper `package.json` for your plugin:

```json
{
  "name": "@mycompany/unify-product-plugin",
  "version": "1.0.0",
  "description": "Product management plugin for Unify",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "test": "jest",
    "dev": "tsc --watch"
  },
  "dependencies": {
    "@unilab/core": "^1.0.0"
  },
  "devDependencies": {
    "typescript": "^5.0.0",
    "jest": "^29.0.0",
    "@types/jest": "^29.0.0"
  },
  "peerDependencies": {
    "@unilab/core": "^1.0.0"
  }
}
```

## Next Steps

- Learn about [Middleware](/docs/middleware/hook) for adding cross-cutting concerns
- Explore [Advanced Integrations](/docs/integrations) for specific frameworks
- Check out the [UniWeb3 Plugin](/docs/plugins/uniweb3) as a real-world example 