---
title: Hook Middleware
description: Hook Middleware is a powerful middleware that allows you to hook into the URPC lifecycle and execute custom logic before and after CRUD operations. This enables you to implement cross-cutting concerns like validation, logging, caching, notifications, and more.
---


## Features

- **Lifecycle Hooks**: Execute logic before and after create, update, and delete operations
- **Universal Hooks**: Use `beforeAny` and `afterAny` hooks for all operations
- **Type Safety**: Full TypeScript support with proper type inference
- **Context Access**: Access to adapter, operation type, and metadata in hook functions
- **Chainable API**: Fluent interface for registering multiple hooks
- **Async Support**: Full support for asynchronous hook functions

## Installation

```bash
npm install @unilab/urpc-core
```

## Basic Usage

### Creating Hook Middleware

Use the `createHookMiddleware` factory function to create a hook middleware:

```typescript
import { createHookMiddleware } from '@unilab/urpc-core/middleware';

const HookMiddleware = createHookMiddleware((hookManager) => {
  hookManager
    .beforeCreate(async (args, _, context) => {
      console.log('Before creating:', args);
      // Validation, data transformation, etc.
    })
    .afterCreate(async (args, result, context) => {
      console.log('After creating:', result);
      // Notifications, logging, etc.
    });
});
```

### Registering with URPC

```typescript
import { URPC } from '@unilab/urpc-hono';

const app = URPC.init({
  plugins: [MyPlugin],
  middleware: [HookMiddleware],
});
```

## Hook Types

### Operation-Specific Hooks

#### Create Hooks
- `beforeCreate`: Executed before entity creation
- `afterCreate`: Executed after successful entity creation

#### Update Hooks
- `beforeUpdate`: Executed before entity update
- `afterUpdate`: Executed after successful entity update

#### Delete Hooks
- `beforeDelete`: Executed before entity deletion
- `afterDelete`: Executed after successful entity deletion

### Universal Hooks
- `beforeAny`: Executed before any operation
- `afterAny`: Executed after any operation

## Hook Function Signature

Each hook function receives three parameters:

```typescript
type HookFunction<T, TArgs, TResult> = (
  args: TArgs,           // Operation arguments
  result?: TResult,      // Operation result (undefined for 'before' hooks)
  context?: {
    adapter: DataSourceAdapter<T>;
    operation: string;
    metadata?: Record<string, any>;
  }
) => Promise<void> | void;
```

### Audit Logging

```typescript
const AuditHooks = createHookMiddleware((hookManager) => {
  hookManager
    .afterCreate(async (args, result, context) => {
      console.log(`AUDIT: Created ${context?.operation} with ID: ${result?.id}`);
    })
    .afterUpdate(async (args, result, context) => {
      console.log(`AUDIT: Updated ${context?.operation} with ID: ${result?.id}`);
    })
    .afterDelete(async (args, result, context) => {
      console.log(`AUDIT: Deleted ${context?.operation}`);
    });
});
```

### Notifications

```typescript
const NotificationHooks = createHookMiddleware((hookManager) => {
  hookManager
    .afterCreate(async (args, result, context) => {
      if (context?.adapter.constructor.name === 'UserAdapter') {
        await sendWelcomeEmail(result.email);
      }
    })
    .afterUpdate(async (args, result) => {
      await sendUpdateNotification(result.id, args.data);
    });
});
```

## Best Practices

1. **Keep Hooks Focused**: Each hook should have a single responsibility
2. **Handle Errors Gracefully**: Use try-catch blocks for non-critical operations
3. **Avoid Heavy Operations**: Keep hooks lightweight to maintain performance
4. **Use Type Safety**: Leverage TypeScript for better development experience
5. **Test Thoroughly**: Write unit tests for your hook logic
6. **Consider Order**: Remember that hooks execute in registration order
