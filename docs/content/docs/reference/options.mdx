---
title: Options
description: Unify provides various configuration options to customize your server behavior, storage, and entity management.
---

## AdapterOptions

Configuration options passed to the Adapter constructor when creating a source.

```typescript
interface AdapterOptions {
  storage?: Storage;
}
```

### storage

Optional storage configuration that determines how data is persisted.

**Type:** `Storage`  
**Default:** No storage (must be provided manually)

## Storage Implementations

Unify provides two built-in storage implementations:

### FileStorage

JSON-based file system storage.

```typescript
import { FileStorage } from "@unify/storage";

const storage = new FileStorage("./data");
```

**Parameters:**
- **dataDir** - Directory path for storing JSON files. Defaults to `"./data"`

### PGStorage

PostgreSQL database-based storage.

```typescript
import { PGStorage } from "@unify/storage";

const storage = new PGStorage({
  connectionString: process.env.DATABASE_URL!,
});
```

**Parameters:**
- **config** - PostgreSQL connection configuration (extends Node.js `pg` PoolConfig)

## SourceConfig

Configuration for registering a data source with entities.

```typescript
interface SourceConfig {
  id: string;
  entities: Record<string, EntityConfig>;
  middleware?: Array<(c: Context, next: () => Promise<void>) => Promise<void>>;
}
```

### id

**Type:** `string`  
**Required:** Yes

Unique identifier for the data source. Used as a prefix for table names and API paths.

### entities

**Type:** `Record<string, EntityConfig>`  
**Required:** Yes

Object mapping entity names to their configurations. Each key becomes an entity endpoint.

### middleware

**Type:** `Array<(c: Context, next: () => Promise<void>) => Promise<void>>`  
**Optional**

Array of Hono middleware functions to apply to all entity routes in this source.

**Example:**
```typescript
const sourceConfig: SourceConfig = {
  id: "blog",
  entities: {
    posts: {
      // EntityConfig
    },
    users: {
      // EntityConfig
    }
  },
  middleware: [
    async (c, next) => {
      console.log(`Request to ${c.req.path}`);
      await next();
    }
  ]
};
```

## EntityConfig

Configuration for individual entities within a source.

```typescript
interface EntityConfig {
  findMany?: EntityProcedure<FindManyArgs>;
  findOne?: EntityProcedure<FindOneArgs>;
  create?: EntityProcedure<CreateArgs>;
  update?: EntityProcedure<UpdateArgs>;
  delete?: EntityProcedure<DeleteArgs>;
  table?: TableSchema;
}
```

### CRUD Operations

Each operation accepts either a custom function or oRPC procedure:

#### findMany

**Type:** `EntityProcedure<FindManyArgs>`  
**Optional**

Handler for retrieving multiple records.

**FindManyArgs:**
```typescript
interface FindManyArgs<T = Record<string, any>> {
  source_id: string;
  limit?: number;
  offset?: number;
  select?: Array<keyof T>;
  where?: Partial<T>;
  order_by?: Partial<Record<keyof T, "asc" | "desc">>;
}
```

#### findOne

**Type:** `EntityProcedure<FindOneArgs>`  
**Optional**

Handler for retrieving a single record.

**FindOneArgs:**
```typescript
interface FindOneArgs<T = Record<string, any>> {
  source_id: string;
  where: Partial<T>;
  select?: Array<keyof T>;
}
```

#### create

**Type:** `EntityProcedure<CreateArgs>`  
**Optional**

Handler for creating new records.

**CreateArgs:**
```typescript
interface CreateArgs<T = Record<string, any>> {
  source_id: string;
  data: Partial<T>;
}
```

#### update

**Type:** `EntityProcedure<UpdateArgs>`  
**Optional**

Handler for updating existing records.

**UpdateArgs:**
```typescript
interface UpdateArgs<T = Record<string, any>> {
  source_id: string;
  where: Partial<T>;
  data: Partial<T>;
}
```

#### delete

**Type:** `EntityProcedure<DeleteArgs>`  
**Optional**

Handler for deleting records.

**DeleteArgs:**
```typescript
interface DeleteArgs<T = Record<string, any>> {
  source_id: string;
  where: Partial<T>;
}
```

### table

**Type:** `TableSchema`  
**Optional**

Database table schema configuration for built-in CRUD operations.

```typescript
interface TableSchema {
  name: string;
  schema?: string;
  columns: Record<string, TableColumn>;
}
```

#### TableSchema Properties

- **name** - Database table name
- **schema** - Database schema name (optional)
- **columns** - Column definitions

#### TableColumn

```typescript
interface TableColumn {
  type: DatabaseColumnType;
  nullable?: boolean;
  unique?: boolean;
  default?: DatabaseDefaultValue;
}
```

## Database Types

### DatabaseColumnType

Supported database column types:

```typescript
type DatabaseColumnType =
  | "varchar" | "text" | "char"
  | "int" | "integer" | "bigint" | "smallint" | "tinyint"
  | "decimal" | "numeric" | "float" | "double" | "real"
  | "boolean" | "bool"
  | "date" | "datetime" | "timestamp" | "time" | "year"
  | "json" | "jsonb"
  | "uuid"
  | "binary" | "varbinary" | "blob" | "longblob" | "mediumblob" | "tinyblob"
  | "enum" | "set";
```

### DatabaseDefaultValue

Supported default values for database columns:

```typescript
type DatabaseDefaultValue =
  | string | number | boolean | object | null
  | "CURRENT_TIMESTAMP" | "CURRENT_DATE" | "CURRENT_TIME"
  | "LOCALTIMESTAMP" | "LOCALTIME"
  | "UUID()" | "AUTO_INCREMENT" | "SERIAL" | "BIGSERIAL" | "NOW()";
```

## REST API Mapping

Unify automatically maps entity operations to REST endpoints:

| Operation | HTTP Method | Path Suffix | Description |
|-----------|-------------|-------------|-------------|
| findMany  | GET         | /list       | Get multiple records |
| findOne   | GET         | /find_one   | Get single record |
| create    | POST        | /create     | Create new record |
| update    | PATCH       | /update     | Update existing record |
| delete    | DELETE      | /delete     | Delete record |

**URL Pattern:** `/{entityName}/{operation}`

## Client Configuration

### ClientOptions

Configuration options when creating a client:

```typescript
interface ClientOptions {
  baseURL: string;
  timeout?: number;
  headers?: Record<string, string>;
}
```

- **baseURL** - Base URL of the API server
- **timeout** - Request timeout in milliseconds
- **headers** - Default request headers

## Complete Example

### Server Side

```typescript
import { createSource } from "@unify/server";
import { PGStorage, FileStorage } from "@unify/storage";
import { os } from "@orpc/server";
import { z } from "zod";

// Create data source
const source = createSource({
  options: {
    // Use PostgreSQL storage
    storage: new PGStorage({
      connectionString: process.env.DATABASE_URL!,
    }),
    // Or use file storage
    // storage: new FileStorage("./data"),
  },
});

// Register source configuration
source.register({
  id: "blog",
  entities: {
    // Custom entity using oRPC procedures
    posts: {
      findMany: os
        .input(z.object({
          where: z.object({
            published: z.boolean().optional(),
          }).optional(),
          limit: z.number().optional(),
        }))
        .output(z.array(z.object({
          id: z.number(),
          title: z.string(),
          content: z.string(),
          published: z.boolean(),
        })))
        .handler(async ({ input }) => {
          // Custom logic
          return [];
        }),
      
      create: os
        .input(z.object({
          title: z.string(),
          content: z.string(),
          published: z.boolean().default(false),
        }))
        .output(z.object({
          id: z.number(),
          title: z.string(),
          content: z.string(),
          published: z.boolean(),
        }))
        .handler(async ({ input }) => {
          // Custom creation logic
          return { id: 1, ...input };
        }),
    },
    
    // Built-in CRUD entity using table schema
    users: {
      table: {
        name: "users",
        schema: "public",
        columns: {
          id: {
            type: "integer",
            nullable: false,
            unique: true,
            default: "AUTO_INCREMENT"
          },
          name: {
            type: "varchar",
            nullable: false
          },
          email: {
            type: "varchar",
            nullable: false,
            unique: true
          },
          created_at: {
            type: "timestamp",
            default: "CURRENT_TIMESTAMP"
          }
        }
      }
    }
  },
  middleware: [
    async (c, next) => {
      // Add CORS headers
      c.header("Access-Control-Allow-Origin", "*");
      await next();
    }
  ]
});

export default {
  port: 3000,
  fetch: source.getApp().fetch,
};
```

### Client Side

```typescript
import { createClient } from "@unify/client";

// Define source configuration (same as server side)
const sourceConfig = {
  id: "blog",
  entities: {
    posts: {
      // oRPC procedure configuration
    },
    users: {
      table: {
        name: "users",
        schema: "public",
        columns: {
          id: { type: "integer" as const },
          name: { type: "varchar" as const },
          email: { type: "varchar" as const },
          created_at: { type: "timestamp" as const }
        }
      }
    }
  }
};

// Create type-safe client
const client = createClient(sourceConfig, {
  baseURL: "http://localhost:3000",
});

// Use the client
async function example() {
  // Get posts list
  const posts = await client.posts.findMany({
    where: { published: true },
    limit: 10,
  });
  
  // Create new user
  const user = await client.users.create({
    data: {
      name: "John Doe",
      email: "john@example.com",
    },
  });
  
  // Update user
  const updatedUser = await client.users.update({
    where: { id: user.data.id },
    data: { name: "Jane Doe" },
  });
  
  console.log("Posts:", posts.data);
  console.log("User:", updatedUser.data);
}
```

### Multi-Source Client

```typescript
import { createClient } from "@unify/client";

const sourceMap = {
  blog: blogSourceConfig,
  ecommerce: ecommerceSourceConfig,
};

const client = createClient(sourceMap, {
  baseURL: "http://localhost:3000",
});

// Access entities from different sources
await client.blog.posts.findMany();
await client.ecommerce.products.findMany();
```
